```
1. TCP三次握手、四次挥手 
2. TCP流量控制、拥塞控制 
3. cookie、session的区别 
4. TCP粘包拆包 
5. IP、http、https 
6. 在浏览器输入一个网址发生了什么
7. OSI 7 层模型和 TCP 4 层模型传输层：TCP/IP 
8. 和 UDP 比较HTTP 协议：报文结构
9. POST/GET 方法网络编程 (socket, NIO, select 等)
```
    网络由下往上分为物理层、数据链路层、网络层（ IP协议）、传输层（ TCP协议）、会话层、表示层和应用层（HTTP协议）

# 1. Tcp三次握手和四次挥手 
建立起一个TCP连接需要经过“三次握手”：
* 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。
* 第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态。
* 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（也就是服务器和客户端交互，最终确定断开）。
![三次握手](https://github.com/HULLzzz/NoteOfNetwork/blob/master/pic/TIM%E6%88%AA%E5%9B%BE20190114161723.png)  
![四次挥手](https://github.com/HULLzzz/NoteOfNetwork/blob/master/pic/3.png)

SYN：代表请求创建连接，所以在三次握手中前两次要SYN=1，表示这两次用于建立连接。  
ACK：代表确认接受，从上面可以发现，不管是三次握手还是四次分手，在回应的时候都会加上ACK=1，表示消息接收到了，并且在建立连接以后的发送数据时，都需加上ACK=1,来表示数据接收成功。  
seq:序列号。当发送一个数据时，数据是被拆成多个数据包来发送，序列号就是对每个数据包进行编号，这样接受方才能对数据包进行再次拼接。  
ack:这个代表下一个数据包的编号，这也就是为什么第二请求时，ack是seq+1。  
FIN：表示请求关闭连接，在四次分手时，我们发现FIN发了两遍。这是因为TCP的连接是双向的，所以一次FIN只能关闭一个方向。   

    为什么进行三次握手？  
* 考虑一次的问题，首先tcp是面向连接，一次握手肯定建立不了连接，因为客户机给服务器发出请求信息却没有得到回应，客户机是没法判定是否发送成功然后建立连接的。  
* 再看两次，假设只有两次握手，比如图中的1，2步，当A想要建立连接时发送一个SYN，然后等待ACK，结果这个SYN因为网络问题没有及时到达B，所以A在一段时间内没收到ACK后，再发送一个SYN，这次B顺利收到，接着A也收到ACK，这时A发送的第一个SYN终于到了B，对于B来说这是一个新连接请求，然后B又为这个连接申请资源，返回ACK，然而这个SYN是个无效的请求，A收到这个SYN的ACK后也并不会理会它，而B却不知道，B会一直为这个连接维持着资源，造成资源的浪费。  
* 三次连接就没毛病了？？是的。两次握手的问题在于服务器端不知道一个SYN是否是无效的，而三次握手机制因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来（A只会承认其中它最早发送的那个SYN的回应，并回复最后一次握手的ACK），服务器便会认为这个SYN是无效的，释放相关资源。但这时有个问题就是客户端完成第二次握手便认为连接已建立，而第三次握手可能在传输中丢失，服务端会认为连接是无效的，这时如果Client端向Server写数据，Server端将以RST包响应，这时便感知到Server的错误。  

总之，三次握手可以保证任何一次握手的失败都是可感知的，不会浪费资源  

    三次握手出现错误时的应对措施  
    
     第一次握手A发送SYN传输失败，A,B都不会申请资源，连接失败。如果一段时间内发出多个SYN连接请求，那么A只会接受它最后发送的那个SYN的SYN+ACK回应，忽略其他回应全部回应，B中多申请的资源也会释放  
     第二次握手B发送SYN+ACK传输失败，A不会申请资源，B申请了资源，但收不到A的ACK，过一段时间释放资源。如果是收到了多个A的SYN请求，B都会回复SYN+ACK，但A只会承认其中它最早发送的那个SYN的回应，并回复最后一次握手的ACK  
     第三次握手ACK传输失败，B没有收到ACK，释放资源，对于后序的A的传输数据返回RST。实际上B会因为没有收到A的ACK会多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到A的ACK，则释放资源，对A的数据传输返回RST    
(原文：https://blog.csdn.net/u013344815/article/details/72134950 )  

    进行四次挥手
第一次服务端向客户端回应FIN的时候，服务端可能有数据未发送完，等服务端发送完之后再次向客户端发送FIN回应

# 2. 流量控制和拥塞控制
#### 流量控制
防止发方发送的太快耗尽接收方的资源从而使接收方来不及处理，使用滑动窗口抑制发送端，告诉发送端发送数据的大小，或者是接收端缓存区的大小。  
#### 拥塞控制
防止发送方发的太快，网络来不及处理，从而导致网络拥塞  
拥塞控制使用的机制：慢启动，执行拥塞避免算法之后，在收到所有的报文段的确认之后，使拥塞窗口缓慢增大，防止网络过早出现拥塞，出现一次超时（第一次网络拥塞）把满开始的门限值设置为当前拥塞窗口的一半。  
网络频繁出现拥塞的时候，门限值就下降的很快，以大大减少注入到网络中的分组数

    为什么拥塞控制？
    
流量控制可以高效可靠的传送大量的数据，但是在刚开始的阶段就发送大量的数据，可能会导致网络的拥堵，因为网络上的计算机太多了  

    流量控制和拥塞控制的区别  
    
* 丢包的位置不同  
流量控制丢包位置是在接收端上，拥塞控制的丢包位置是在路由器上
* 作用的对象不同  
流量控制的对象是接收方，怕发送方发送的太快接收方来不及处理  
拥塞控制的对象是网络，怕发送方发的太快造成网络的拥塞，使网络来不及处理
  　
# 3. cookie、session的区别
cookie机制采用的是在客户端保持状态的方案，在客户端记录确定用户身份，而session机制采用的是在服务器端保持状态的方案，在服务端记录信息确定用户身份。  
HTTP是无状态协议，一旦数据交换完毕，客户端和服务器就断开连接，有新的数据交换就建立新的连接。  
客户端请求服务器，如果服务器需要记录客户端的状态，就会使用response给客户端浏览器颁发一个cookie，客户端会保存这个cookie，浏览器再次访问服务器的时候，会将url和cookie一同发送给服务器，服务器根据cookie判断用户的状态。  
每个用户访问服务器都会建立一个session，服务器通过sessionId判断用户的状态，通过sessionId作为key值，读写到对应的value，就达到了保持会话的目的。使用cookie将每次的sessionId送到服务器  

    如果客户端禁用cookie时候有两种方法实现session不依赖cookie  
    
 URL重写：在url中添加sessionId  
表单隐藏字段：在表单中添加隐藏字段以便在表单提交的时候回传sessionId给服务器。
   
    总结  
    
* cookie数据存放在客户端的浏览器上，session数据存放在服务器上  
* cookie不是很安全，别人可以通过存放在本地的cookie解析进行cookie欺骗，密码和登陆信息可以使用session，其他信息使用cookie
* session会在一定时间内保存在服务器上，访问量增大的话，影响服务器性能，考虑减轻服务器性能上，可使用cookie


# 6. 在浏览器输入一个网址发生了什么 
在浏览器中输入一个网址之后浏览器的处理过程如下:
```
第一步 浏览器查找该域名的 IP 地址

第二步 浏览器根据解析得到的IP地址向 web 服务器发送一个 HTTP 请求

第三步 服务器收到请求并进行处理

第四步 服务器返回一个响应

第五步 浏览器对该响应进行解码，渲染显示。

第六步 页面显示完成后，浏览器发送异步请求。
```
当用户在浏览器输入www.taobao.com这个url并回车之后，将发生的操作有：
#### 1.DNS解析
  首先它会请求DNS把这个域名解析成对应的IP地址，然后根据这个IP在互联网上找到对应的服务器，向服务器发起get请求。首先查找浏览器缓存，
浏览器会保存一段时间内访问过的一些网址的DNS信息，没找到对应的记录，这时候浏览器会尝试调用操作系统缓存继续查找，仍没有找到，接着会
发送请求到路由器上，路由器在自己的路由器缓存中查找记录，仍没有找到，这个请求会被发送到ISP（互联网服务提供商），ISP有相应的ISP DNS服务器，
就是本地DNS服务器，请求的域名基本都能在这里找到，如果还是没有的话ISP的DNS服务器会将请求发向根域名服务器，就是面向全球的顶级DNS服务器，（真正的实体
服务器有好几百台，分布在全球的各大洲），若仍没有，说明这个域名不存在或者已经过期了。<br>
所以DNS根据域名查询IP地址的过程为：浏览器缓存 --> 操作系统缓存 --> 路由器缓存-->本地（ISP）域名服务器缓存 --> 根域名服务器。<br>
得到IP之后，向服务器发送TCP连接，TCP连接经过三次握手
#### 2. 浏览器发送HTTP请求
浏览器和服务器建立连接之后，浏览器接着给这个IP地址的服务器发送一个HTTP请求，方式为get，例如访问www.baidu.com。其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。
这个get请求包含了主机（Host）、用户代理(User-Agent)，用户代理就是自己的浏览器，它是你的"代理人"，Connection（连接属性）中的keep-alive表示浏览器告诉对方服务器在传输完现在请求的内容后不要断开连接，不断开的话下次继续连接速度就很快了。可能还会有Cookies，Cookies保存了用户的登陆信息，一般保存的是用户的JSESSIONID，在每次向服务器发送请求的时候会重复发送给服务器。
在建立连接发送请求时每个服务端需要和客户端保持通信，有很多客户端都会和服务器进行通信。服务器为了识别是哪个客户端与它通信，就必须用一个标识记录客户端的信息。客户端首次访问服务器，服务端返回响应时通过附带一个记录的客户端信息的标识来返回给客户端，这个标识就是JSESSIONID，JSESSIONID就放在了客户端的Cookies里。当客户端再次向服务器发送请求时上就使用上次记录的Cookies里面的JSESSIONID，这样服务器就知道是哪个浏览器了。这样他们之间就能保持通信了。<br>
发送完请求接下来就是等待回应了.
#### 3. 服务器处理请求
服务器收到浏览器的请求以后，会解析这个请求（读请求头），然后生成一个响应头和具体响应内容。接着服务器会传回来一个响应头和一个响应，
响应头告诉了浏览器一些必要的信息，例如重要的Status Code，2开头如200表示一切正常，3开头表示重定向，4开头是客户端错误，如404表示请求的资源不存在，5开头表示服务器端错误。
响应就是具体的要请求的页面内容。
#### 4. 浏览器解析渲染页面
  在浏览器显示HTML时，打开一个网页的过程中，主页（index）页面框架传送过来以后，浏览器还会因页面上的静态资源多次发起连接请求，需要获取嵌入在HTML中的其他地址的资源。这时，浏览器会发送一些请求来获取这些文件。这些内容也要一点点地请求过来，所以标签栏转啊转，内容刷啊刷，最后全部请求并加载好了就终于好了。
静态的文件一般会从CDN中去取，CDN根据请求获取资源的时候可能还会用到负载均衡。<br>
CDN也就是内容分发网络(Content Delivery Network)，它是构筑在现有Internet上的一种先进的流量分配网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。<br>
    对于那些动态的请求，动态网页等就必须要从服务器获取了。对于静态的页面内容，浏览器通常会进行缓存，而对于动态的内容，浏览器通常不会进行缓存。对于这些动态请求，Nginx可能会专门设置一些服务器用来处理这些访问动态页面的请求。
#### 5. 关闭TCP连接
当数据完成请求到返回的过程之后，根据Connection的Keep-Alive属性可以选择是否断开TCP连接，HTTP/1.1一般支持同一个TCP多个请求，而不是1.0版本下的完成一次请求就发生断开。TCP的断开与连接不一样，断开可以分为主动关闭和被动关闭，需要经过4次握手。
当浏览器需要的全部数据都已经加载完毕，一个页面就显示完了。

（原文：https://blog.csdn.net/kongmin_123/article/details/82555936 ）

